'''Generates annotation data sets for cross-validation of deepNF embeddings.

Saves a .mat file containing arrays of genes and their associated GO terms for
each of the three GO ontologies and for three levels of term counts in each
ontology.

Usage:
    python cross_validation_annotations.py
'''
import os
import itertools
import numpy as np
from scipy import io
import pandas as pd
from collections import defaultdict
from goatools.obo_parser import GODag
from goatools.associations import read_gaf
from agape.exceptions import GeneOntologyError
import copy
from goatools.godag_obosm import OboToGoDagSmall
from agape.gene_ontology import go_annotations
from agape.utils import directory_exists
from agape.base import Base


def parent_terms(go_dag, go_id):
    '''Return parent terms of `go_id` in a `go_dag`.
    '''
    sub_dag = OboToGoDagSmall(goids=[go_id], obodag=go_dag).godag
    all_parents = list(sub_dag.go2obj.keys())
    return all_parents


def propagate_parent_terms(associations, go_dag):
    '''Propagate gene annotations to parent terms.

    # Arguments
        associations: dict, mapping genes to GO terms generated by
            agape.GO.get_associations
    '''
    for gene, go_ids in associations.items():
        for go_id in go_ids.copy():
            try:
                parents = parent_terms(go_dag, go_id)
                for i in parents:
                    associations[gene].add(i)
            except KeyError as err:
                err.args = (f'Obsolete term: {err.args[0]}',)
                pass
    return associations


def get_gene_index():
    '''Return a dictionary mapping genes to array indices.
    '''
    genes = pd.read_csv(
        os.path.join(
            os.path.expandvars('$AGAPEDATA'),
            'deepNF',
            'cerevisiae_net_genes.csv'),
        header=None)
    _, genes = genes[0].str.split('.').str
    return {k: v for k, v in zip(sorted(genes), range(len(genes)))}


def get_go_id_index(d):
    '''Return a dictionary mapping GO terms to array indices.
    '''
    go_ids = set(itertools.chain(*d.values()))
    return {k: v for k, v in zip(sorted(go_ids), range(len(go_ids)))}


def fill_array_of_associations(M, associations, gene_indexes, go_id_indexes):
    '''Return an array of associations between genes and GO terms.

    Shape = [n_go_terms, n_genes]

    # Arguments
        M: array, np.zeros((n_go_terms, n_genes))
        gene_indexes: dict, mapping genes to array indices
        go_id_indexes: dict, mapping GO terms to array indices

    # Returns
        M: array, filled
    '''
    for gene, go_ids in associations.items():
        try:
            gene_index = gene_indexes[gene]
            for go_id in go_ids:
                go_id_index = go_id_indexes[go_id]
                M[go_id_index, gene_index] = 1
        except KeyError as err:
            # print(err)
            pass
    return M


def get_subarray_by_term_counts(M, vmin, vmax):
    '''Return a subarray containing terms with vmin <= count <= vmax.

    # Arguments
        M: array, associations between genes and GO terms
        vmin: int, minimum term count
        vmax: int, maximum term count

    # Returns
        M: subarray
    '''
    n_terms = M.sum(1)
    M = M[(vmin <= n_terms) & (n_terms <= vmax), :]
    return M


def filter_similar_terms(M, threshold=0.1):
    '''Filter out similar GO terms.

    # Arguments
        M: array, associations between genes and GO terms
        threshold: float, Jaccard similarity threshold

    # Returns
        M: subarray, with similar terms filtered out
    '''
    termsize = M.sum(1)
    indexes = termsize.argsort()
    M = M[indexes]

    intersection = M @ M.T
    union = M.shape[1] - (1 - M) @ (1 - M).T
    jacc = intersection / union

    max_jacc = np.triu(jacc, 1).max(1)
    M = M[max_jacc <= threshold]
    return M


class GO(Base):
    """Handles S. pombe gene ontology annotations.

    # Arguments
        args: str, sets of GO evidence codes to be included
    """
    def __init__(self, *allowed_evidence_codes,
                 go_dag_path='$AGAPEDATA/go.obo',
                 associations_path='$AGAPEDATA/gene_association.pombase'):
        super().__init__()

        self.set_evidence_codes()
        self.set_allowed_evidence_codes(allowed_evidence_codes)
        self.go_dag_path = os.path.expandvars(go_dag_path)
        self.associations_path = os.path.expandvars(associations_path)

    def set_evidence_codes(self):
        self.evidence_codes = {
            "taxon": {
                "Taxon_ID": {
                    "taxon:4896", "taxon:284812"}},
            "protein": {
                "DB_Object_Type": {
                    "protein"}},
            "experimental": {
                "Evidence": {
                    "EXP", "IDA", "IPI", "IMP", "IGI", "IEP", "HDA", "HMP"}},
            "computational": {
                "Evidence": {
                    "ISS", "ISO", "ISA", "ISM", "IGC", "IBA", "IBD", "IKR",
                    "IRD", "RCA"}},
            "curated": {
                "Evidence": {
                    "IC", "TAS"}},
            "automatic": {
                "Evidence": {
                    "IEA"}},
            "bad": {
                "Evidence": {
                    "NAS", "ND"}}}

        for k, v in self.evidence_codes.items():
            setattr(self, k, v)

    def set_allowed_evidence_codes(self, allowed_evidence_codes):
        """Set which evidence code sets to include when iterating over `GO`.

        # Arguments
            allowed_evidence_codes: list, keys of `self.evidence_codes`
        """
        try:
            self.allowed_evidence_codes = [self.evidence_codes[i] for i in
                                           allowed_evidence_codes] \
                if len(allowed_evidence_codes) > 0 else None
        except KeyError as err:
            raise GeneOntologyError(
                f"Not a valid evidence code set: {err.args[0]}")

    def load_go_dag(self):
        """Load GO DAG.

        # Arguments
            filepath: str (optional), path to go.obo
        """
        filepath = self.go_dag_path
        if not os.path.exists(filepath):
            raise GeneOntologyError(f"{os.path.basename(filepath)} does not exist at {os.path.dirname(filepath)}")

        go_dag = GODag(filepath)
        self.go_dag = go_dag

    def set(self, name, value):
        setattr(self, name, value)

    def get(self, name):
        return getattr(self, name)

    def __iter__(self):
        """Iterate over annotations.
        """
        filepath = self.associations_path
        if not os.path.exists(filepath):
            raise GeneOntologyError(f"{os.path.basename(filepath)} does not exist at {os.path.dirname(filepath)}")

        if not hasattr(self, "go_dag"):
            self.load_go_dag()

        with go_annotations(filepath) as f:
            for rec in f:
                # Remove obsolete terms
                if rec["GO_ID"] in self.go_dag:
                    # Only iterate over proteins
                    # if record_has(rec, self.protein):
                        # Only iterate over allowed evidence codes
                        if self.allowed_evidence_codes is not None:
                            # Yield annotation if it has an allowed evidence code
                            if any([record_has(rec, ec) for ec in self.allowed_evidence_codes]):
                                old_id = rec['DB_Object_ID']
                                old_symbol = rec['DB_Object_Symbol']
                                rec["DB_Object_Symbol"] = old_id
                                rec["DB_Object_ID"] = old_symbol
                                yield rec
                        # Otherwise iterate over all evidence codes
                        else:
                            yield rec

    def get_associations(self, ontology=None):
        """Get associations of gene IDs to GO terms.

        Ontologies: P = biological process, F = molecular function,
            C = cellular component

        # Arguments
            ontology: str (optional), one of {"P", "F", "C"}

        # Returns
            dict: maps gene IDs to the GO terms it is annotated them

        # Raises
            GeneOntologyError: if `ontology` is not valid
        """
        if ontology is not None and ontology not in ("P", "F", "C"):
            raise GeneOntologyError(f"Not a valid ontology: {ontology}")

        # Load a defaultdict mapping gene_ids to the GO terms annotated to them
        # if not hasattr(self, "all_associations"):
        associations = read_gaf(self.associations_path)

        mapping = {rec['DB_Object_Symbol']: rec['DB_Object_ID'] for rec in self}

        self.all_associations = {}
        for i in associations:
            if i in mapping:
                self.all_associations[mapping[i]] = associations[i]

        all_associations = copy.deepcopy(self.all_associations)

        # Remove genes that do not have any annotations with an accepted
        # evidence code
        wanted_genes = set(rec["DB_Object_ID"] for rec in self)
        associations = self.remove_unwanted_genes(wanted_genes, all_associations)
        # Only consider GO terms from a particular ontology
        if ontology is not None:
            # term2ontology_dict = self.term2ontology()
            d = self.ontology2term()
            accepted_terms = d[ontology]
            # Iterate over dictionary of associations
            for gene, go_terms in associations.items():
                for go_id in go_terms.copy():
                    # Remove obsolete terms
                    if go_id in self.go_dag:
                        # Remove GO terms from other ontologies
                        if go_id not in accepted_terms:
                            go_terms.remove(go_id)

        self.associations = associations
        return associations

    def remove_unwanted_genes(self, wanted_genes, associations):
        """Remove unwanted genes from the set of annotations.

        # Arguments
            wanted_genes: set, genes to keep in `associations`
            associations: defaultdict, associations read by `read_gaf` mapping
                gene_ids to the GO terms annotated to them
        """
        # Get `unwanted_genes` that do not have any annotations with an
        # accepted evidence code
        all_genes = set(associations)
        unwanted_genes = all_genes - set(wanted_genes)

        # Delete the unwanted genes from `associations`
        for gene in unwanted_genes:
            del associations[gene]
        return associations

    def term2ontology(self) -> dict:
        """Maps GO terms to their ontology.
        """
        if not hasattr(self, "term2ontology_d"):
            d = {rec["GO_ID"]: rec["Aspect"] for rec in self}
            self.term2ontology_d = d
        return self.term2ontology_d

    def ontology2term(self) -> defaultdict:
        """Maps ontologies to the GO terms in that ontology.
        """
        if not hasattr(self, "term2term2ontology_d"):
            self.term2ontology()

        d_r = defaultdict(set)
        for go_id, ontology in self.term2ontology_d.items():
            d_r[ontology].add(go_id)
        self.ontology2term_d = d_r
        return d_r


def main():
    '''Run for each ontology and for three levels of term counts.
    '''
    # Load GO DAG
    go = GO("experimental", "computational", "curated",
            go_dag_path='$CEREVISIAEDATA/go.obo',
            associations_path='$CEREVISIAEDATA/gene_association.sgd')

    go.load_go_dag()
    go_dag = go.go_dag

    # Set `vmin` and `vmax` for each level of term counts
    ontology_sizes = [(101, 300), (31, 100), (11, 30)]

    # Names of the three ontologies
    ontologies = ['P', 'F', 'C']

    # Save arrays for each ontology and level
    associations_ontologies_levels = {}

    # Loop over ontologies
    for ontology in ontologies:
        print('Calculating for ontology', ontology)
        # Get dict mapping genes to GO terms
        associations = go.get_associations(ontology)
        # Add parent terms
        associations = propagate_parent_terms(associations, go_dag)
        # Get dicts for mapping to array indexes
        gene_indexes = get_gene_index()
        go_id_indexes = get_go_id_index(associations)

        # Loop over levels of term counts
        for idx, (vmin, vmax) in enumerate(ontology_sizes):
            print('Min/max term counts', vmin, vmax)
            # Get associations between genes and GO terms
            M = np.zeros((max(go_id_indexes.values()) + 1,
                          max(gene_indexes.values()) + 1))
            print(M.shape)
            M = fill_array_of_associations(M, associations, gene_indexes,
                                           go_id_indexes)
            M = get_subarray_by_term_counts(M, vmin, vmax)
            print('Shape before filtering terms by Jaccard similarity', M.shape)
            # Filter terms by Jaccard similarity
            # M = filter_similar_terms(M)
            print('Shape after filtering terms by Jaccard similarity', M.shape)
            # Save array
            associations_ontologies_levels[f'{ontology}_{idx + 1}'] = M.T

    # Save `associations_ontologies_levels` to a .mat file
    output_dir = os.path.join(os.path.expandvars('$CEREVISIAEDATA'),
                              'deepNF',
                              'annotations')
    directory_exists(output_dir)
    output_file = 'yeast_annotations.mat'
    io.savemat(
        os.path.join(output_dir, output_file),
        associations_ontologies_levels,
        do_compression=True)

    print(f'{output_file} saved to {output_dir}')


if __name__ == '__main__':
    print(__doc__)
    main()
